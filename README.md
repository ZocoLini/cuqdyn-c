# Uncertainty Quantification in Dynamic Models of Biological Systems Using Conformal Prediction

This project is a transpilation of the Matlab project
defined in this [paper](https://zenodo.org/records/13838652).

## Index

- [Project Structure](#project-structure)
- [Dependencies](#dependencies)
- [ENV Vars](#env-vars)
- [Building the project](#building-the-project)
- [Using the CLI](#using-the-cli)
- [Input files](#input-files)
- [Defining a new model](#defining-a-new-model)

## Project Structure

The project is structured as follows:

- `deps/`: Contains the dependencies of the project.
- `modules/`: Contains the different modules of the project.
    - `cli/`: CLI that enables the use of the cuqdyn-c library.
    - `cuqdyn-c/`: The main library that implements the functionality of the paper project.
    - `cvodes_old/`: Old version of the cvodes library that was used in the sacess library.
    - `dotmat-introspector/`: Console app to introspect the contents of a .mat file.
    - `sacess/`: [External proyect](https://bitbucket.org/DavidPenas/sacess-library) adapted to enable the
      use of eSS in C.
    - `mexpreval/`: Rust crate. Parses the model from the XML file to evaluate it.
- `tests/`: Constains the tests of the cuqdyn-c library.
- `CUQDyn/`: Contains the original Matlab project.

## Dependencies

- xml2-2.9.1
- matio-2.9.1 (Built by CMake)
- hdf5-1.8.12 (Built by CMake)
- gsl-1.14 (Built by CMake if not present)

## ENV Vars

### CUQDYN_DEF_YDOT

When running this software, there is a chance of generating an inf or NaN value. Take for example the following ODE:

```xml
<ode_expr y_count="1" p_count="2">
    p1 * y1 * (1 - y1 / p2)
</ode_expr>
```

If the value of `p2` generated by the eSS solver is 0, the model eval produces an inf value. To avoid this, when the
evaluation of the ODE generates a non finite value, the software will set the value of the variable to 0. If you
want to change this behavior, you can set the value you want the variable to take when an invalid value is
generated by setting the environment variable `CUQDYN_DEF_YDOT` to the desired value.

### SACESS_SEED

Set this variable if you want to set the seed used by the eSS solver instead of 
generating a random one.

## Building the project

**GCC and GFortran v14 aren't supported by the project, so you need to use GCC v13 or lower.**

The project has a `build.sh` script.
`build-[variant]/` directories will be created, each one representing a variant
off the project builded. If you call the script without arguments, it will build
all the variants, but you can also specify the variant you want, passing it as the
first argument. The available variants are:

- `serial`: Builds the project to only execute serial methods.
- `mpi`: Builds the project to execute the sequential solver in parallel using MPI.
- `mpi2`: Builds the project to only include the MPI and OpenMP defined in sacess-library.
  
After this, running `test.sh` is a good way to know if the cuqdyn library works as expected.

## Using the CLI

After building using the `build.sh` script, you can execute this command to run the CLI
with example config and data files like this:

```bash
mkdir output
./build-{variant}/modules/cli/cli solve \
    -c example-files/lotka_volterra_cuqdyn_config.xml \
    -s example-files/lotka_volterra_ess_{variant}_config.xml \
    -d example-files/lotka_volterra_paper_data.txt \
    -o output/
```

```bash
mkdir output
./build-{variant}/modules/cli/cli solve \
    -c example-files/alpha_pinene_cuqdyn_config.xml \
    -s example-files/alpha_pinene_ess_{variant}_config.xml \
    -d example-files/alpha_pinene_paper_data.txt \
    -o output/
```

```bash
mkdir output
./build-{variant}/modules/cli/cli solve \
    -c example-files/logistic_model_cuqdyn_config.xml \
    -s example-files/logistic_model_ess_{variant}_config.xml \
    -d example-files/logistic_model_paper_data.txt \
    -o output/
```

After this, the file `output/cuqdyn-results.txt` contains the results of the
algorithm but reading it as a plain text is not very useful.
To fix this, you can run: (Needs python3 and matplotlib installed)

```bash
python3 plot.py output/cuqdyn-results.txt
```

This will save a graphic representation for each y(t) in different png files
inside the directory where the results are (output folder in this example).

To get information about all the options the cli supports, you can run the following command:

```bash
./build-{variant}/modules/cli/cli help
```

Also, you can run

```bash
./build-{variant}/modules/cli/cli version
```

to get the version of the cuqdyn-c lib and cli you are using.

## Input files

There are three types of input files needed to run the cli:

- **eSS Solver config xml:**
  This file contains the configuration of the eSS solver used in the sacess library.
  The specifications of this xml and how to build it are in
  this [link](https://bitbucket.org/DavidPenas/sacess-library/src/main/doc/manual/DOCUMENTATION_SACESS_SOFTWARE.pdf).
- **cuqdyn config xml:**
  This file contains the configuration of the cuqdyn solver used in the cuqdyn-c library.
  This file defines the rtol and atol used by the cvodes library inside the tolerances block
  and the ode model inside the ode_expr block. In the following example we define the Lotka Volterra model.
  There is an option to accelerate the process of evaluating the ODE by defining it inside the 
  mevalexpr module. We will talk about this later.
  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>

  <cuqdyn-config>
      <tolerances>
          <rtol>1e-8</rtol>
          <atol>1e-9, 1e-10</atol>
      </tolerances>
      <ode_expr y_count="2" p_count="4">
          y1 * (p1 - p2 * y2)
          -y2 * (p3 - p4 * y1)
      </ode_expr>
  </cuqdyn-config>
  ```
- **Data file:**
  The data file containing a mtrix of observed data and the initial value
  needed to solve the ODE. The data file can be a .mat file where the first matrix
  found will be used (`test/data/lotka_volterra_data_homoc_noise_0.10_size_30_data_1.mat`)
  or a txt file written with the following format:
  ```
  # The first row is gonna be used as the initial condition
  31 3 # Matrix dimensions so the parsing is easier
  0 10 5 # Column 1: time, Column 2: y1(t), Column 3: y2(t)
  .
  .
  .
  30 1e1 5e1
  ```

## Defining a new model

Using strings and evaluate them is slow compared to compiled instructions, so, to make this
 possible, we designed a way to define the models in Rust and compile them to machine code.

Let's dig into it with an example of the Lotka Volterra model:

First of all, we need to write some Rust code. We will be using the following file
`modules/mexpreval/src/models.rs`. Inside, we create a new unit struct and implement 
the Model trait like this:
```Rust
#[derive(Default)]
struct LotkaVolterra;

impl Model for LotkaVolterra {
    fn eval(&self, _t: f64, y: &[f64], ydot: &mut [f64], p: &[f64]) {
        ydot[0] = y[0] * (p[0] - p[1] * y[1]);
        ydot[1] = - y[1] * (p[2] - p[3] * y[0]);
    }
}
```

Once the model is defined, we should give it an identifier:
```Rust
pub fn eval_model_fun(model: &str, ode_expr: &OdeExpr) -> Box<dyn Model> {
    match model {
        "lotka-volterra" => Box::new(LotkaVolterra::default()),
        "alpha-pinene" | "Î±-pinene" => Box::new(AlphaPinene::default()),
        _ => Box::new(GenericModel::new(ode_expr))
    }
}
```

After you establish an identifier in the match at the bottom of the file, the model can be 
used indicating the identifier in the XML config file like this:

  ```xml
<?xml version="1.0" encoding="UTF-8" ?>

  <cuqdyn-config>
      <tolerances>
          <rtol>1e-8</rtol>
          <atol>1e-9, 1e-10</atol>
      </tolerances>
      <ode_expr y_count="2" p_count="4">
          lotka-volterra
      </ode_expr>
  </cuqdyn-config>
  ```

Note that y_count and p_count are still present.
